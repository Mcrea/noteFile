<html>
    <head></head>
    <body>
        <h1>坐标和依赖</h1>
        <p>坐标是构件的坐标，依赖是项目对于构件（jar包）的依赖。</p>
        <h2>定义坐标</h2>
        <p>广泛意义上的坐标是某个参考系的唯一标识。maven的坐标继承了这个概念，只是它的参考系是一堆数量庞大的构件。maven坐标定义了构件的唯一标识。</p>
        <p>如果你想问这有什么意义，君不见公司项目下大量意义不明的jar包以及每次找不到需求的jar包而不得不去上网搜罗下载的情形吗？</p>
        <h2>maven坐标实现</h2>
        <p>maven坐标定义为一组元素：<font color="red">groupId,artifactId,version,packaging,classifier。</font></p>
        <h3>groupId</h3>
        <p>定义当前maven项目隶属于的实际项目。maven项目多为模块化代码，在一定程度上是职责单一高度抽象的功能模块。因此常常是多个maven项目处于同一个实际项目的情形。
            但是这也不是绝对的。它的值通常是实际项目的反向域名。</p>
        <h3>artifactId</h3>
        <p>定义的实际项目下的一个maven项目，它的值通常是实际项目名作为前缀。</p>
        <h3>version</h3>
        <p>定义maven项目当前的版本</p>
        <h3>packaging</h3>
        <p>定义maven项目的打包方式</p>
        <h3>classifier</h3>
        <p>帮助定义构建输出一些附属构件，不能直接定义</p>
        <h3>maven项目文件名</h3>
        <p>artifactId-version.packaging</p>
        <h3>demo</h3>
        <p>&ltgroupId>org.sonatype.nexus&lt/groupId></p>
        <p>&ltartifactId>nexus-indexer&lt/artifactId></p>
        <p>&ltversion>2.0.0&lt/version></p>
        <p>&ltpackaging>jar&lt/packaging></p>
        <p>maven项目文件名：nexus-indexer-2.0.0.jar</p>
        <h2>依赖配置</h2>
        <p>maven项目的依赖配置在pom.xml文件中，除了坐标相关的那几个属性外，依赖还有其他的属性可以配置。一般只要配置依赖的坐标即可，但是依赖配置显然不仅仅只会指定构件的坐标</p>
        <h3>依赖范围（scope）</h3>
        <p>依赖范围就是用于控制依赖和三种classpath（编译、运行、测试）的关系。maven在执行这三种操作时会使用不同的classpath。而且在不同的操作时依赖可以是不同的。这导致了依赖范围这个概念的出现</p>
        <table>
            <tr><th>依赖范围</th><th>编译</th><th>测试</th><th>运行</th><th>例子</th></tr>
            <tr><td>compile</td><td>y</td><td>y</td><td>y</td><td>spring-core</td></tr>
            <tr><td>test</td><td>n</td><td>y</td><td>n</td><td>jUnit</td></tr>
            <tr><td>provided</td><td>y</td><td>y</td><td>n</td><td>servlet-api</td></tr>
            <tr><td>runtime</td><td>n</td><td>y</td><td>y</td><td>jdbc</td></tr>
            <tr><td>system(慎用)</td><td>y</td><td>y</td><td>n</td><td>本地jar</td></tr>
        </table>
        <h3>传递性依赖</h3>
        <p>传递性依赖就是项目的直接依赖的jar依赖于其他jar包的情形。如果不使用maven，处理jar之间的依赖将是一个棘手的问题。但是maven很好的解决了这一点。</p>
        <p>在maven项目中，都有一个pom文件配置了直接依赖。这样当我们的项目依赖于某个maven项目（jar）时，除了引入这个直接依赖的jar之外，maven还会查看该jar的pom文件去引入
            它的直接依赖，这个对于我们项目来说就是间接依赖或者传递性依赖。这就是maven的传递依赖机制
        </p>
        <h3>依赖范围和传递性依赖</h3>
        <h4>依赖范围传递</h4>
        <table>
            <tr><th>第一依赖/第二依赖</th><th>compile</th><th>test</th><th>provided</th><th>runtime</th></tr>
            <tr><td>compile</td><td>compile</td><td>-</td><td>-</td><td>runtime</td></tr>
            <tr><td>test</td><td>test</td><td>-</td><td>-</td><td>test</td></tr>
            <tr><td>provided</td><td>provided</td><td>-</td><td>provided</td><td>provided</td></tr>
            <tr><td>runtime</td><td>runtime</td><td>-</td><td>-</td><td>runtime</td></tr>
        </table>
        <h3>依赖调整</h3>
        <p>maven帮助我们解决了依赖传递的问题，我们只需要知道第一依赖即可，这个依赖的依赖不需要关心。但是不总是有效的。有时候甚至需要我们手动调节。</p>
        <p>问题主要来源于间接依赖的重复引入，对于不同的直接依赖可能会导致相同的间接依赖的出现。为了确保依赖的一致性和唯一性，maven有两个调整原则</p>
        <h4>maven依赖调整原则</h4>
        <p>路径最短原则</p>
        <p>声明优先原则</p>
        <h3>可选依赖</h3>
        <p>可选依赖的概念类似于策略模式，而且不会被传递。如果一个maven项目有多个可选依赖，maven不会去主动寻找这些可选依赖，而是需要你在自己的项目中为它声明。
            你给它声明的可选依赖就是策略，这个maven项目会根据策略进行不同的动作。不建议使用</p>
        <h3>最佳实践</h3>
        <h4>排除依赖</h4>
        <p>在传递性依赖方面，maven解决了我们的寻找jar包的麻烦，但是也会引入新的问题。比如引入了某个不稳定版本的依赖，或者某些传递性依赖maven找不到等等。
            针对这个问题，maven提供了排除依赖的功能，在pom声明依赖时，可以使用exclusions标签来排除该依赖的传递性依赖，只需要groupId和artifactId即可。
            然后再自己声明一下想要的jar包提供给这个依赖。</p>
        <h4>归类依赖</h4>
        <p>对于同一实际项目下的maven项目，他们往往有着同样的version属性。我们可以声明一个version变量，在依赖的声明中引入这个变量，这样容易修改，并且确保了version
            的一致。
        </p>
        <p>maven提供了这样的功能，这些需要一个maven的属性properties，在这个属性中，类似于&ltvar>123&lt/var>声明了变量var的值为123。在声明依赖时，使用${var}引用即可</p>
        <h4>优化依赖</h4>
        <p>maven会自动解析所有项目的直接依赖和传递性依赖，并且根据规则正确的判断每个依赖的范围。对于一些依赖冲突，也能自动调节。确保每一个构件只有唯一的版本在依赖中存在。
            最后得到的那些依赖被称为已解析依赖。可使用mvn dependency:list命令查看。而且，由于依赖的层级关系，还可以使用mvn dependency:tree查看每个依赖的路径。这样可以详细
            的查看项目中所有的依赖及其他们之间的关系。
        </p>
        <p>mvn dependency:analyze会根据代码分析依赖的可能存在的问题。它会提示使用却未被声明的依赖。这种依赖通过其他直接依赖的传递而来。不够稳定。还会提示声明却未被使用
            的依赖。但是这些依赖需要好好分析再决定去留。因为它的分析范围只是编译和测试。总之，我们要确保依赖的稳定和清晰。
        </p>
    </body>
</html>